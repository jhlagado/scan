.engine mycomputer

.include "constants.asm"
    DSIZE equ $80
    RSIZE equ $80
    LSIZE equ $80
    TIBSIZE equ $100		; 256 bytes , along line!
    mintDataSize equ 26*2*2	; A..Z, a..z words

.include "test.fast.mac.asm"
.include "IOSerial.asm"

    LD SP,DSTACK
    jp start

.include "ram.asm"

.org $4000

; Generate a table from JavaScript
; Array.from(Array(128).keys()).sort((a, b) => 0.5 - Math.random());

.align $100
pearTable:
    db 96,105,113,101,114,102,99,107,100,103,120,87,10,83,71,3,58,13,21,22,124
    db 23,45,121,117,92,2,82,44,26,53,62,110,37,14,64,11,31,72,91,93,50,12,8,17
    db 32,74,1,25,127,39,60,61,24,73,59,108,16,125,69,112,115,20,77,43,29,97,15
    db 65,49,0,38,90,4,5,30,98,19,84,86,18,42,126,6,80,119,56,27,54,33,68,52,67
    db 66,28,46,109,85,111,63,75,116,79,7,94,51,70,40,106,34,88,76,118,57,55,48
    db 78,35,81,41,36,47,9,89,122,104,95,123

;==============================================================================
; Calculates an 7-bit hash value from a sequence of bytes by referencing
; a lookup table.  The table is aligned on a 256-byte memory boundary.
;
; INPUTS:  HL: Pointer to byte sequence
;          DE: Pointer to table at 256-byte boundary
;           B: number of bytes in sequence
; OUTPUTS:  A: Hash value
;          HL: Points to byte after the end of the sequence
;           B: 0
; Destroys DE
;==============================================================================

pearSeven:
    ld de, pearTable
    xor a
pearSeven1:
    xor (hl)    ; Get current hash XOR'd with next byte in the sequence.
    ld  e, a
    ld  a, (de)
    inc hl      ; Next byte in sequence
    djnz PearSeven1
    ret

printStr:                       ;=14
    EX (SP),HL		; swap			
    CALL putStr		
    INC HL			; inc past null
    EX (SP),HL		; put it back	
    RET

putStr0:
    CALL putchar
    INC HL
putStr:
    LD A,(HL)
    OR A
    JR NZ,putStr0
    RET

printdec:                           ;=36
    LD DE,-10000			; mint ., 5th location of a dev number
    CALL printdec1			; text book method look it up
    LD DE,-1000
    CALL printdec1
    LD DE,-100
    CALL printdec1
    LD E,-10
    CALL printdec1
    LD E,-1
printdec1:	    
    LD A,'0'-1
printdec2:	    
    INC A
    ADD HL,DE
    JR C,printdec2
    SBC HL,DE
    JP putchar


hello: 
    .pstr "hello"

start:
    ld hl, hello
    ld b, (hl)
    inc hl
    call pearSeven
    ld l, a
    ld h, 0
    push hl
    expect "hello", $30
    halt
    
